/**
 * Created by nctuong on 4/26/2017.
 */
/**
 * Kafka REST proxy
 * Confluent Kafka REST proxy
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD.
        define(['expect.js', '../../src/index'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS-like environments that support module.exports, like Node.
        factory(require('expect.js'), require('../../src/index'));
    } else {
        // Browser globals (root is window)
        factory(root.expect, root.KafkaRestProxy);
    }
}(this, function(expect, KafkaRestProxy) {
    'use strict';

    var instance;

    beforeEach(function() {
        instance = new KafkaRestProxy.ConsumerApi();
    });

    var getProperty = function(object, getter, property) {
        // Use getter method if present; otherwise, get the property directly.
        if (typeof object[getter] === 'function')
            return object[getter]();
        else
            return object[property];
    }

    var setProperty = function(object, setter, property, value) {
        // Use setter method if present; otherwise, set the property directly.
        if (typeof object[setter] === 'function')
            object[setter](value);
        else
            object[property] = value;
    }

    describe('Consumer', function() {
        /**
         * Send a message to topic
         * @param topicName
         * @param message
         * @param doneCallBack
         */
        function sendMessage(topicName, message , doneCallBack) {
            var produceMessages = new KafkaRestProxy.ProduceMessages();
            var createTopicMessage = new KafkaRestProxy.Record();
            createTopicMessage.value = message;
            produceMessages.records = [createTopicMessage];
            var topicApi = new KafkaRestProxy.TopicApi();

            topicApi.produceMessageToTopic(topicName, produceMessages, function (error, data) {
                if (error) {
                    doneCallBack(error);
                }
            });
            doneCallBack();
        }

        /**
         * Create an consumer instance and subscribe it to a topic
         * @param consumerName
         * @param groupName
         * @param done
         * @param topicName
         */
        function createConsumerAndSubscribeTopic(consumerName, groupName, topicName, done) {
            var consumerApi = new KafkaRestProxy.ConsumerApi();

            var consumerRequest = new KafkaRestProxy.ConsumerRequest();
            consumerRequest.name = consumerName;
            consumerRequest.format = "json";
            consumerRequest["auto.offset.reset"] = "latest";
            consumerRequest["auto.commit.enable"] = "true";

            consumerApi.createInstanceToGroup(groupName, {consumerRequest: consumerRequest}, function (error, data) {
                if (error) {
                    if (error.response.res.statusCode !== 409) { // instance exists.
                        done(error);
                        return;
                    }
                }
                // subscribe for the topic
                var topicRequest = new KafkaRestProxy.TopicSubscriptionRequest();
                topicRequest.topics = [topicName];

                consumerApi.subscribesTopics(groupName, consumerName, {topics: topicRequest}, function (error, data) {
                    if (error) {
                        done(data);
                        return;
                    }

                    done();
                });
            });
        }

        describe('read', function() {
            const topicName = "testing_topic";
            const groupName = "test_group";
            const consumerName = "Consumer_Test";

            before(function (done) {
                // create a topic "testing_topic"
                sendMessage(topicName, "Create Topic", done);
            });

            it('should read message from a message', function(done) {
                // act
                // create an consumer instance
                createConsumerAndSubscribeTopic(consumerName, groupName, topicName, function (error) {
                    if(error){
                        done(error);
                        return;
                    }
                    sendMessage(topicName, "Message", function(error){
                        if(error){
                            done(error);
                            return;
                        }
                        var consumerApi = new KafkaRestProxy.ConsumerApi();
                        consumerApi.fetchData(groupName, consumerName, null, function (error, data) {
                            if (error) {
                                done(error);
                                return;
                            }
                            // assert
                            expect(data.length).to.greaterThan(0);
                            var found = false;
                            for (var i = 0; i < data.length; i++) {
                                var message = data[i];
                                if (message.value === "Message") {
                                    found = true;
                                    break;
                                }
                            }
                            expect(found).to.be(true);

                            done();
                        });
                    });
                });
            });

            it("twice should return new messages in the 2nd read", function(done) {
                //TODO: implementation
               done();
            });

            it("wait for 5 seconds and return empty when no new messages in topic", function (done) {
                //TODO: implementation
                done();
            });
        });

        describe('instance', function() {
            it('should automatically removed after X seconds', function(done) {
                //TODO: implementation
                done();
            });
        });
    });
}));
